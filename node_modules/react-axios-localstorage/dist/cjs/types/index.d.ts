import { AxiosError, AxiosRequestConfig } from 'axios';
export declare type AxiosCacheConfig = Partial<AxiosCacheConfigProps>;
export interface AxiosCacheConfigProps {
    /**
     * invalidator is a unique identifier used for comparison on invocation.
     * If this value differs from what is currently stored in the cache, then the
     * cached value will be invalidated and re-retrieved from the requested endpoint
     * on the next invocation.
     * This is useful in the event that we want to invalidate our cache based on something
     * non-url related, such as logged-in status.
     *
     * @default url.search (query string parameters)
     *
     * @example
     * ```
     * const props = {invalidator: 'custom'}
     * // creates an invalidator for product_custom
     * // if the invalidator or query string params change, then the value will be invalidated
     * // on next request.
     * useAxiosCache('key', 'url?search=product', props)
     * ```
     *
     * @type {string}
     * @memberof AxiosCacheConfigProps
     */
    invalidator?: string;
    /**
     * bypass indicates manual bypassing of the cache.
     * This is useful for instances that you want to ignore cached values, such as
     * when retrieving data from a CMS in preview mode.
     *
     * @default false
     * @type {boolean}
     * @memberof AxiosCacheConfigProps
     */
    bypass: boolean;
    /**
     * prefix is prepended to the front of the `cacheKey` parameter to construct an
     * identifiable cache key
     *
     * @default 'ral'
     *
     * @type {string}
     * @memberof AxiosCacheConfigProps
     */
    prefix: string;
    /**
     * version will cause an invalidation of the cached value if the value changes on
     * subsequent requests. This is useful in a redeployment scenario when you want to
     * make sure the cache is refreshed after a release. When using Github Actions,
     * the value will default to the GITHUB_SHA value.
     *
     * @default process.env.GITHUB_SHA
     *
     * @type {string}
     * @memberof AxiosCacheConfigProps
     */
    version?: string;
    /**
     * invalidationMS is the time in milliseconds after which a cached value should be invalidated
     * and refreshed.
     *
     * @default 300000 // 5 * 60 * 1000 === 5 minutes
     *
     * @type {number}
     * @memberof AxiosCacheConfigProps
     */
    invalidationMS: number;
}
export interface AxiosCacheStatus<T> {
    data: T | undefined;
    error: AxiosError | unknown | undefined;
    loading: boolean;
}
export declare const defaultConfig: AxiosCacheConfigProps;
/**
 * useAxiosCache wraps axios.get for the specified url and @see AxiosRequestConfig
 * It also incorporates localstorage caching based on the provided cacheKey and
 * @see AxiosCacheConfig
 *
 * @example const { data, loading } = useAxiosCache('products', 'https://mysite.com/api/v1/products');
 *
 * @template T
 * @param {string} cacheKey
 * @param {string} url
 * @param {AxiosCacheConfig} [config]
 * @param {AxiosRequestConfig<unknown>} [axiosConfig]
 * @return {*}  {AxiosCacheStatus<T>}
 */
export declare const useAxiosCache: <T>(cacheKey: string, url: string, config?: Partial<AxiosCacheConfigProps> | undefined, axiosConfig?: AxiosRequestConfig<unknown> | undefined) => AxiosCacheStatus<T>;
/**
 * invalidateCache will use the provided prefix
 * to remove cached items. It will remove ALL items with the
 * prefix
 *
 * @param {string} [prefix] defaults to 'ral'
 */
export declare const invalidateCache: (prefix?: string | undefined) => void;
export default useAxiosCache;
